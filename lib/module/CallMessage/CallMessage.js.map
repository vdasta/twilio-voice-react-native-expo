{"version":3,"names":["InvalidArgumentError","validateCallMessage","message","content","messageType","contentType","contentStr","JSON","stringify"],"sources":["CallMessage.ts"],"sourcesContent":["/**\n * Copyright Â© 2022 Twilio, Inc. All rights reserved. Licensed under the Twilio\n * license.\n *\n * See LICENSE in the project root for license information.\n */\n\nimport { InvalidArgumentError } from '../error/InvalidArgumentError';\n\n/**\n * The constituent values of a Call Message.\n *\n * @public\n */\nexport interface CallMessage {\n  /**\n   * The content of the message. This value should match the content type\n   * parameter.\n   *\n   * See {@link CallMessage.contentType} for more information.\n   */\n  content: any;\n\n  /**\n   * The content type of the message. This value should accurately describe\n   * the content of the message. The following values are accepted:\n   *\n   * - \"application/json\"\n   *\n   * If no value is defined, then the default value of \"application/json\" will\n   * be used.\n   *\n   * If the `contentType` of the message is \"application/json\", the content\n   * of the message may be a JS object.\n   */\n  contentType?: string;\n\n  /**\n   * The message type. The following values are accepted:\n   *\n   * - \"user-defined-message\"\n   */\n  messageType: string;\n}\n\n/**\n * Parse CallMessage values. Used when constructing a CallMessage from the\n * native layer, or by the Call and CallInvite classes when sending a\n * CallMessage.\n *\n * @param message the CallMessage details.\n *\n * @internal\n */\nexport function validateCallMessage(message: CallMessage) {\n  const content = message.content;\n  const messageType = message.messageType;\n\n  let contentType = message.contentType;\n\n  if (typeof contentType === 'undefined') {\n    contentType = 'application/json';\n  }\n\n  if (typeof contentType !== 'string') {\n    throw new InvalidArgumentError(\n      'If \"contentType\" is present, it must be of type \"string\".'\n    );\n  }\n\n  if (typeof messageType !== 'string') {\n    throw new InvalidArgumentError('\"messageType\" must be of type \"string\".');\n  }\n\n  if (typeof content === 'undefined' || content === null) {\n    throw new InvalidArgumentError('\"content\" must be defined and not \"null\".');\n  }\n\n  const contentStr =\n    typeof content === 'string' ? content : JSON.stringify(content);\n\n  return { content: contentStr, contentType, messageType };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,oBAAoB,QAAQ,+BAA+B;;AAEpE;AACA;AACA;AACA;AACA;;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAACC,OAAoB,EAAE;EACxD,MAAMC,OAAO,GAAGD,OAAO,CAACC,OAAO;EAC/B,MAAMC,WAAW,GAAGF,OAAO,CAACE,WAAW;EAEvC,IAAIC,WAAW,GAAGH,OAAO,CAACG,WAAW;EAErC,IAAI,OAAOA,WAAW,KAAK,WAAW,EAAE;IACtCA,WAAW,GAAG,kBAAkB;EAClC;EAEA,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIL,oBAAoB,CAC5B,2DACF,CAAC;EACH;EAEA,IAAI,OAAOI,WAAW,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIJ,oBAAoB,CAAC,yCAAyC,CAAC;EAC3E;EAEA,IAAI,OAAOG,OAAO,KAAK,WAAW,IAAIA,OAAO,KAAK,IAAI,EAAE;IACtD,MAAM,IAAIH,oBAAoB,CAAC,2CAA2C,CAAC;EAC7E;EAEA,MAAMM,UAAU,GACd,OAAOH,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAGI,IAAI,CAACC,SAAS,CAACL,OAAO,CAAC;EAEjE,OAAO;IAAEA,OAAO,EAAEG,UAAU;IAAED,WAAW;IAAED;EAAY,CAAC;AAC1D","ignoreList":[]}