"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreflightTest = void 0;
var _eventemitter = require("eventemitter3");
var common = _interopRequireWildcard(require("./common"));
var _constants = require("./constants");
var _error = require("./error");
var _utility = require("./error/utility");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
 * Copyright Â© 2025 Twilio, Inc. All rights reserved. Licensed under the Twilio
 * license.
 *
 * See LICENSE in the project root for license information.
 */
/**
 * The PreflightTest for Voice React Native SDK allows you to anticipate and
 * troubleshoot end users' connectivity and bandwidth issues before or during
 * Twilio Voice calls.
 *
 * You can run a PreflightTest before a Twilio Voice call. The PreflightTest
 * performs a test call to Twilio and provides a
 * {@link (PreflightTest:namespace).Report} object at the end. The report
 * includes information about the end user's network connection (including
 * jitter, packet loss, and round trip time) and connection settings.
 *
 * @example
 * ```typescript
 * const accessToken = ...;
 * const preflightTest = voice.runPreflightTest(accessToken);
 *
 * preflightTest.on(PreflightTest.Event.Connected, () => {
 *   // handle when preflightTest connects
 * });
 *
 * preflightTest.on(PreflightTest.Event.Completed, (report: PreflightTest.Report) => {
 *   // handle when preflightTest is complete
 * });
 *
 * preflightTest.on(PreflightTest.Event.Failed, (error: TwilioError) => {
 *   // handle preflightTest errors
 * });
 *
 * preflightTest.on(
 *   PreflightTest.Event.QualityWarning,
 *   (currentWarnings: Call.QualityWarning[], previousWarnings: Call.QualityWarning[]) => {
 *     // handle preflightTest quality warnings
 *   },
 * );
 *
 * preflightTest.on(PreflightTest.Event.Sample, (sample: PreflightTest.Sample) => {
 *   // handle preflightTest sample
 * });
 * ```
 */
class PreflightTest extends _eventemitter.EventEmitter {
  /**
   * PreflightTest constructor.
   *
   * @internal
   */
  constructor(_uuid) {
    super();
    /**
     * UUID of the PreflightTest. This is generated by the native layer and used
     * to link events emitted by the native layer to the respective JS object.
     */
    _defineProperty(this, "_uuid", void 0);
    /**
     * Handle all PreflightTest native events.
     */
    _defineProperty(this, "_handleNativeEvent", nativePreflightTestEvent => {
      const uuid = nativePreflightTestEvent[_constants.Constants.PreflightTestEventKeyUuid];
      if (typeof uuid !== 'string') {
        throw new _error.InvalidStateError(`Unexpected PreflightTest UUID type: "${uuid}".`);
      }
      if (uuid !== this._uuid) {
        return;
      }

      // VBLOCKS-5083
      // Update this member access when we upgrade typescript for this project.
      switch (nativePreflightTestEvent.preflightTestEventKeyType) {
        case _constants.Constants.PreflightTestEventTypeValueCompleted:
          {
            return this._handleCompletedEvent(nativePreflightTestEvent);
          }
        case _constants.Constants.PreflightTestEventTypeValueConnected:
          {
            return this._handleConnectedEvent();
          }
        case _constants.Constants.PreflightTestEventTypeValueFailed:
          {
            return this._handleFailedEvent(nativePreflightTestEvent);
          }
        case _constants.Constants.PreflightTestEventTypeValueQualityWarning:
          {
            return this._handleQualityWarningEvent(nativePreflightTestEvent);
          }
        case _constants.Constants.PreflightTestEventTypeValueSample:
          {
            return this._handleSampleEvent(nativePreflightTestEvent);
          }
        default:
          {
            const _exhaustiveCheck = nativePreflightTestEvent;
            throw new _error.InvalidStateError(`Unexpected native PreflightTest event key type: "${_exhaustiveCheck[_constants.Constants.PreflightTestEventKeyType]}".`);
          }
      }
    });
    /**
     * Handle completed event.
     */
    _defineProperty(this, "_handleCompletedEvent", nativeEvent => {
      const report = nativeEvent[_constants.Constants.PreflightTestCompletedEventKeyReport];
      if (typeof report !== 'string') {
        throw constructInvalidValueError(PreflightTest.Event.Completed, 'report', 'string', typeof report);
      }
      const parsedReport = parseReport(report);
      this.emit(PreflightTest.Event.Completed, parsedReport);
    });
    /**
     * Handle connected event.
     */
    _defineProperty(this, "_handleConnectedEvent", () => {
      this.emit(PreflightTest.Event.Connected);
    });
    /**
     * Handle failed event.
     */
    _defineProperty(this, "_handleFailedEvent", nativeEvent => {
      const {
        message,
        code
      } = nativeEvent[_constants.Constants.PreflightTestFailedEventKeyError];
      if (typeof message !== 'string') {
        throw constructInvalidValueError(PreflightTest.Event.Failed, 'message', 'string', typeof message);
      }
      if (typeof code !== 'number') {
        throw constructInvalidValueError(PreflightTest.Event.Failed, 'code', 'number', typeof code);
      }
      const error = (0, _utility.constructTwilioError)(message, code);
      this.emit(PreflightTest.Event.Failed, error);
    });
    /**
     * Handle quality warning event.
     */
    _defineProperty(this, "_handleQualityWarningEvent", nativeEvent => {
      const currentWarnings = nativeEvent[_constants.Constants.PreflightTestQualityWarningEventKeyCurrentWarnings];
      if (!Array.isArray(currentWarnings)) {
        throw constructInvalidValueError(PreflightTest.Event.QualityWarning, 'currentWarnings', 'array', typeof currentWarnings);
      }
      currentWarnings.forEach(w => {
        if (typeof w !== 'string') {
          throw constructInvalidValueError(PreflightTest.Event.QualityWarning, 'element-in-currentWarnings', 'string', typeof w);
        }
      });
      const previousWarnings = nativeEvent[_constants.Constants.PreflightTestQualityWarningEventKeyPreviousWarnings];
      if (!Array.isArray(previousWarnings)) {
        throw constructInvalidValueError(PreflightTest.Event.QualityWarning, 'previousWarnings', 'array', typeof previousWarnings);
      }
      previousWarnings.forEach(w => {
        if (typeof w !== 'string') {
          throw constructInvalidValueError(PreflightTest.Event.QualityWarning, 'element-in-previousWarnings', 'string', typeof w);
        }
      });
      this.emit(PreflightTest.Event.QualityWarning, currentWarnings, previousWarnings);
    });
    /**
     * Handle sample event.
     */
    _defineProperty(this, "_handleSampleEvent", nativeEvent => {
      const sampleStr = nativeEvent[_constants.Constants.PreflightTestSampleEventKeySample];
      if (typeof sampleStr !== 'string') {
        throw constructInvalidValueError(PreflightTest.Event.Sample, 'sample', 'string', typeof sampleStr);
      }
      const sampleObj = JSON.parse(sampleStr);
      this.emit(PreflightTest.Event.Sample, parseSample(sampleObj));
    });
    this._uuid = _uuid;
    common.NativeEventEmitter.addListener(_constants.Constants.ScopePreflightTest, this._handleNativeEvent);

    // by using a setTimeout here, we let the call stack empty before we flush
    // the preflight test events. this way, listeners on this object can bind
    // before flushing
    if (common.Platform.OS === 'ios') {
      common.setTimeout(() => {
        common.NativeModule.preflightTest_flushEvents();
      });
    }
  }
  /**
   * Internal helper method to invoke a native method and handle the returned
   * promise from the native method.
   */
  async _invokeAndCatchNativeMethod(method) {
    return method(this._uuid).catch(error => {
      if (typeof error.code === 'number' && error.message) throw (0, _utility.constructTwilioError)(error.message, error.code);
      if (error.code === _constants.Constants.ErrorCodeInvalidStateError) throw new _error.InvalidStateError(error.message);
      throw error;
    });
  }

  /**
   * Get the CallSid of the underlying Call in the PreflightTest.
   *
   * @returns
   * Promise that
   * - Resolves with a string representing the CallSid.
   * - Rejects if the native layer could not find the CallSid for this
   *   PreflightTest object.
   */
  async getCallSid() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_getCallSid);
  }

  /**
   * Get the end time of the PreflightTest.
   *
   * @returns
   * A Promise that
   * - Resolves with `number` if the PreflightTest has ended.
   * - Resolves with `undefined` if PreflightTest has not ended.
   * - Rejects if the native layer encountered an error.
   */
  async getEndTime() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_getEndTime).then(Number);
  }

  /**
   * Get the latest stats sample generated by the PreflightTest.
   *
   * @returns
   * A Promise that
   * - Resolves with the last {@link (PreflightTest:namespace).RTCSample}
   *   generated by the PreflightTest.
   * - Resolves with `undefined` if there is no previously generated sample.
   * - Rejects if the native layer encountered an error.
   */
  async getLatestSample() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_getLatestSample).then(sampleStr => {
      const sampleObj = JSON.parse(sampleStr);
      return parseSample(sampleObj);
    });
  }

  /**
   * Get the final report generated by the PreflightTest.
   *
   * @returns
   * A Promise that
   * - Resolves with the final {@link (PreflightTest:namespace).Report}.
   * - Resolves with `undefined` if the report is unavailable.
   * - Rejects if the native layer encountered an error.
   */
  async getReport() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_getReport).then(parseReport);
  }

  /**
   * Get the start time of the PreflightTest.
   *
   * @returns
   * A Promise that
   * - Resolves with a `number` representing the start time of the
   *   PreflightTest.
   * - Rejects if the native layer encountered an error.
   */
  async getStartTime() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_getStartTime).then(Number);
  }

  /**
   * Get the state of the PreflightTest.
   *
   * @returns
   * A Promise that
   * - Resolves with the current state of the PreflightTest.
   * - Rejects if the native layer encountered an error.
   */
  async getState() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_getState).then(parseState);
  }

  /**
   * Stop the ongoing PreflightTest.
   *
   * @returns
   * A Promise that
   * - Resolves if the PreflightTest was successfully stopped.
   * - Rejects if the native layer encountered an error.
   */
  async stop() {
    return this._invokeAndCatchNativeMethod(common.NativeModule.preflightTest_stop);
  }
}

/**
 * Preflight helper functions to parse JSON strings from the native layer into
 * proper JS objects to emit from this class.
 */

/**
 * Parse native time measurement.
 */
exports.PreflightTest = PreflightTest;
function parseTimeMeasurement(nativeTimeMeasurement) {
  return {
    duration: nativeTimeMeasurement.duration,
    end: nativeTimeMeasurement.endTime,
    start: nativeTimeMeasurement.startTime
  };
}

/**
 * Parse native call quality enum.
 */
function parseCallQuality(nativeCallQuality) {
  switch (common.Platform.OS) {
    case 'android':
      {
        return parseCallQualityAndroid(nativeCallQuality);
      }
    case 'ios':
      {
        return parseCallQualityIos(nativeCallQuality);
      }
    default:
      {
        throw new _error.InvalidStateError('Invalid platform.');
      }
  }
}

/**
 * Parse call quality value for Android platform.
 */
function parseCallQualityAndroid(nativeCallQuality) {
  if (typeof nativeCallQuality === 'undefined' || nativeCallQuality === null) {
    return null;
  }
  if (typeof nativeCallQuality !== 'string') {
    throw new _error.InvalidStateError(`Call quality not of type "string". Found "${typeof nativeCallQuality}".`);
  }
  const parsedCallQuality = callQualityMap.android.get(nativeCallQuality);
  if (typeof parsedCallQuality !== 'string') {
    throw new _error.InvalidStateError(`Call quality invalid. Expected a string, found "${nativeCallQuality}".`);
  }
  return parsedCallQuality;
}

/**
 * Parse call quality for iOS platform.
 */
function parseCallQualityIos(nativeCallQuality) {
  if (typeof nativeCallQuality === 'undefined' || nativeCallQuality === null) {
    return null;
  }
  if (typeof nativeCallQuality !== 'number') {
    throw new _error.InvalidStateError(`Call quality not of type "number". Found "${typeof nativeCallQuality}".`);
  }
  const parsedCallQuality = callQualityMap.ios.get(nativeCallQuality);
  if (typeof parsedCallQuality !== 'string') {
    throw new _error.InvalidStateError(`Call quality invalid. Expected [0, 4], found "${nativeCallQuality}".`);
  }
  return parsedCallQuality;
}

/**
 * Parse native preflight test state value.
 */
function parseState(nativeState) {
  const parsedState = preflightTestStateMap.get(nativeState);
  if (typeof parsedState !== 'string') {
    const expectedKeys = Array(preflightTestStateMap.keys()).join(', ');
    throw new _error.InvalidStateError('PreflightTest state invalid. ' + `Expected one of "[${expectedKeys}]". Got "${nativeState}".`);
  }
  return parsedState;
}

/**
 * Parse a sample object and transform the keys to match the expected output.
 */
function parseSample(sampleObject) {
  const audioInputLevel = sampleObject.audioInputLevel;
  const audioOutputLevel = sampleObject.audioOutputLevel;
  const bytesReceived = sampleObject.bytesReceived;
  const bytesSent = sampleObject.bytesSent;
  const codec = sampleObject.codec;
  const jitter = sampleObject.jitter;
  const mos = sampleObject.mos;
  const packetsLost = sampleObject.packetsLost;
  const packetsLostFraction = sampleObject.packetsLostFraction;
  const packetsReceived = sampleObject.packetsReceived;
  const packetsSent = sampleObject.packetsSent;
  const rtt = sampleObject.rtt;
  const timestamp = Number(sampleObject.timestamp);
  const sample = {
    audioInputLevel,
    audioOutputLevel,
    bytesReceived,
    bytesSent,
    codec,
    jitter,
    mos,
    packetsLost,
    packetsLostFraction,
    packetsReceived,
    packetsSent,
    rtt,
    timestamp
  };
  return sample;
}

/**
 * Parse native "isTurnRequired" value.
 */
function parseIsTurnRequired(isTurnRequired) {
  switch (common.Platform.OS) {
    case 'android':
      {
        return parseIsTurnRequiredAndroid(isTurnRequired);
      }
    case 'ios':
      {
        return parseIsTurnRequiredIos(isTurnRequired);
      }
    default:
      {
        throw new _error.InvalidStateError('Invalid platform.');
      }
  }
}

/**
 * Parse native "isTurnRequired" value on Android.
 */
function parseIsTurnRequiredAndroid(isTurnRequired) {
  if (typeof isTurnRequired === 'undefined' || isTurnRequired === null) {
    return null;
  }
  if (typeof isTurnRequired !== 'boolean') {
    throw new _error.InvalidStateError(`PreflightTest "isTurnRequired" not valid. Found "${isTurnRequired}".`);
  }
  return isTurnRequired;
}

/**
 * Parse native "isTurnRequired" value on iOS.
 */
function parseIsTurnRequiredIos(isTurnRequired) {
  if (typeof isTurnRequired === 'undefined' || isTurnRequired === null) {
    return null;
  }
  if (typeof isTurnRequired !== 'string') {
    throw new _error.InvalidStateError('PreflightTest "isTurnRequired" not of type "string". ' + `Found "${isTurnRequired}".`);
  }
  const parsedValue = isTurnRequiredMap.ios.get(isTurnRequired);
  if (typeof parsedValue !== 'boolean') {
    throw new _error.InvalidStateError(`PreflightTest "isTurnRequired" not valid. Found "${isTurnRequired}".`);
  }
  return parsedValue;
}

/**
 * Parse native warnings array.
 */
function parseWarnings(warnings) {
  if (typeof warnings === 'undefined' || warnings === null) {
    return [];
  }
  if (!Array.isArray(warnings)) {
    throw new _error.InvalidStateError(`PreflightTest "warnings" invalid. Found "${warnings}".`);
  }
  return warnings;
}

/**
 * Parse native warningsCleared array.
 */
function parseWarningsCleared(warningsCleared) {
  if (typeof warningsCleared === 'undefined' || warningsCleared === null) {
    return [];
  }
  if (!Array.isArray(warningsCleared)) {
    throw new _error.InvalidStateError(`PreflightTest "warningsCleared" invalid. Found "${warningsCleared}".`);
  }
  return warningsCleared;
}

/**
 * Parse native preflight report.
 */
function parseReport(rawReport) {
  const unprocessedReport = JSON.parse(rawReport);
  const callSid = unprocessedReport.callSid;

  // Note: Android returns enum values where the first letter is capitalized.
  // The helper function normalizes this into all-lowercased values.
  const callQuality = parseCallQuality(unprocessedReport.callQuality);
  const edge = unprocessedReport.edge;

  // Note: key change from `iceCandidates` to `iceCandidateStats`
  const iceCandidateStats = unprocessedReport.iceCandidates;

  // Note: iOS returns a string, Android returns a boolean
  const isTurnRequired = parseIsTurnRequired(unprocessedReport.isTurnRequired);

  // Note: key change from `networkStats` to `stats`.
  const stats = unprocessedReport.networkStats;

  // Note: removing preflightTest from networkTiming and putting it in a
  // separate testTiming member
  const unprocessedNetworkTiming = unprocessedReport.networkTiming;

  // Note: nested key change from `startTime` to `start` and `endTime` to `end`.
  const networkTiming = {
    signaling: parseTimeMeasurement(unprocessedNetworkTiming.signaling),
    peerConnection: parseTimeMeasurement(unprocessedNetworkTiming.peerConnection),
    ice: parseTimeMeasurement(unprocessedNetworkTiming.iceConnection)
  };

  // Note: nested key change from `startTime` to `start` and `endTime` to `end`.
  const testTiming = parseTimeMeasurement(unprocessedNetworkTiming.preflightTest);

  // Note: key change from `statsSamples` to `stats`.
  const samples = unprocessedReport.statsSamples.map(parseSample);
  const selectedEdge = unprocessedReport.selectedEdge;

  // Note: key change from `selectedIceCandidatePair` to `selectedIceCandidatePairStats`.
  const selectedIceCandidatePairStats = unprocessedReport.selectedIceCandidatePair;

  // Note: iOS returns undefined where Android returns an empty array
  // when there were no warnings
  const warnings = parseWarnings(unprocessedReport.warnings);

  // Note: iOS returns undefined where Android returns an empty array
  // when there were no warningsCleared
  const warningsCleared = parseWarningsCleared(unprocessedReport.warningsCleared);
  const report = {
    callSid,
    callQuality,
    edge,
    iceCandidateStats,
    isTurnRequired,
    stats,
    networkTiming,
    testTiming,
    samples,
    selectedEdge,
    selectedIceCandidatePairStats,
    warnings,
    warningsCleared
  };
  return report;
}

/**
 * Helper function to construct errors when the native layer sends an
 * unexpected value to the JS layer.
 */
function constructInvalidValueError(eventName, valueName, expectedType, actualType) {
  return new _error.InvalidStateError(`Invalid "preflightTest#${eventName}" value type for "${valueName}". ` + `Expected "${expectedType}"; actual "${actualType}".`);
}

/**
 * Helper types for the PrefligthTest class.
 */
(function (_PreflightTest) {
  /**
   * Options to run a PreflightTest.
   */
  /**
   * Events raised by the PreflightTest.
   */
  let Event = /*#__PURE__*/function (Event) {
    Event["Connected"] = "connected";
    Event["Completed"] = "completed";
    Event["Failed"] = "failed";
    Event["Sample"] = "sample";
    Event["QualityWarning"] = "qualityWarning";
    return Event;
  }({});
  _PreflightTest.Event = Event;
  let State = /*#__PURE__*/function (State) {
    State["Connected"] = "connected";
    State["Completed"] = "completed";
    State["Connecting"] = "connecting";
    State["Failed"] = "failed";
    return State;
  }({});
  _PreflightTest.State = State;
  /**
   * Represents general stats for a specific metric.
   */
  /**
   * Represents RTC related stats that are extracted from RTC samples.
   */
  /**
   * Timing measurements that provide operational milestones.
   */
  /**
   * Represents network related time measurements.
   */
  /**
   * A warning that can be raised by the `PreflightTest` and returned in the
   * `PreflightTest.Report.warnings` field.
   */
  /**
   * Signifies when a `PreflightTest.Warning` has been cleared. Emitted by the
   * `PreflightTest` when the warning was cleared and also included in the
   * `PreflightTest.Report.warningsCleared` field.
   */
  /**
   * Provides information related to the ICE candidate.
   */
  /**
   * The `PreflightTest.RTCIceCandidateStats` of the selected remote and local
   * ICE candidates.
   */
  /**
   * A sample generated during the progress of a `PreflightTest`.
   */
  /**
   * The call quality.
   */
  let CallQuality = function (CallQuality) {
    CallQuality[CallQuality["Excellent"] = _constants.Constants.PreflightCallQualityExcellent] = "Excellent";
    CallQuality[CallQuality["Great"] = _constants.Constants.PreflightCallQualityGreat] = "Great";
    CallQuality[CallQuality["Good"] = _constants.Constants.PreflightCallQualityGood] = "Good";
    CallQuality[CallQuality["Fair"] = _constants.Constants.PreflightCallQualityFair] = "Fair";
    CallQuality[CallQuality["Degraded"] = _constants.Constants.PreflightCallQualityDegraded] = "Degraded";
    return CallQuality;
  }({});
  _PreflightTest.CallQuality = CallQuality;
  /**
   * The final report generated by the `PreflightTest` upon completion. Contains
   * info related to the call quality and RTC statistics generated during the
   * `PreflightTest`.
   */
})(PreflightTest || (exports.PreflightTest = PreflightTest = {}));
/**
 * Map of call quality values from the native layer to the expected JS values.
 */
const callQualityMap = {
  ios: new Map([[0, PreflightTest.CallQuality.Excellent], [1, PreflightTest.CallQuality.Great], [2, PreflightTest.CallQuality.Good], [3, PreflightTest.CallQuality.Fair], [4, PreflightTest.CallQuality.Degraded]]),
  android: new Map([['Excellent', PreflightTest.CallQuality.Excellent], ['Great', PreflightTest.CallQuality.Great], ['Good', PreflightTest.CallQuality.Good], ['Fair', PreflightTest.CallQuality.Fair], ['Degraded', PreflightTest.CallQuality.Degraded]])
};

/**
 * Map of isTurnRequired values from the native layer to the expected JS values.
 */
const isTurnRequiredMap = {
  ios: new Map([['true', true], ['false', false]])
};

/**
 * Map of state values from the native layers/common constants to the expected
 * JS values.
 */
const preflightTestStateMap = new Map([[_constants.Constants.PreflightTestStateCompleted, PreflightTest.State.Completed], [_constants.Constants.PreflightTestStateConnected, PreflightTest.State.Connected], [_constants.Constants.PreflightTestStateConnecting, PreflightTest.State.Connecting], [_constants.Constants.PreflightTestStateFailed, PreflightTest.State.Failed]]);
//# sourceMappingURL=PreflightTest.js.map